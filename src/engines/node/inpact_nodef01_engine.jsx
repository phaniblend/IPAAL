import createINPACTEngine from "../inpact_engine_shared";
const NODES = [
  { id: "intro", type: "reveal", phase: "Problem", content: { tag: "NODE.JS #1", title: "Node.js Core — fs, path & process", body: `Node.js is a JavaScript runtime built on Chrome's V8 engine.\nIt adds file system access, process control, networking, and more.\n\nCore modules (no install needed):\n  fs      — file system reads/writes\n  path    — cross-platform path joining\n  process — env vars, args, exit codes\n  os      — system info\n\nRule: always use path.join() — never string-concat paths.\nRule: prefer fs.promises (async) over sync versions in servers.`, usecase: "Every Node.js backend reads config files, serves static assets, or processes uploads — all require fs and path fluency." } },
  { id: "objectives", type: "objectives", phase: "Objectives", items: ["Read and write files with fs.promises", "Use path.join and path.resolve correctly", "Access environment variables via process.env", "Parse process.argv for CLI tools", "Use os module for system info", "Build a simple config loader"] },
  { id: "step1", type: "question", phase: "Step 1 of 5", paal: "Read a file async with fs.promises.readFile. Write a file. Check if it exists.", answer_keywords: ["fs.promises", "readfile", "writefile", "await"], seed_code: `import fs from 'fs/promises'\nimport { existsSync } from 'fs'\n\nasync function readConfig(filePath) {\n  try {\n    const content = await fs.readFile(filePath, 'utf8')\n    return JSON.parse(content)\n  } catch (err) {\n    if (err.code === 'ENOENT') throw new Error(\`Config not found: \${filePath}\`)\n    throw err\n  }\n}\n\nasync function writeConfig(filePath, data) {\n  await fs.writeFile(filePath, JSON.stringify(data, null, 2), 'utf8')\n}\n\n// Check existence without try/catch:\nif (existsSync('./config.json')) {\n  console.log('config exists')\n}\n\nexport { readConfig, writeConfig }`, feedback_correct: "✅ fs.promises for async I/O. err.code === 'ENOENT' for missing file detection.", feedback_partial: "fs.promises.readFile(path, 'utf8') — returns string. fs.promises.writeFile(path, data).", feedback_wrong: "import fs from 'fs/promises'; await fs.readFile(path, 'utf8')", expected: "fs.promises read/write" },
  { id: "step2", type: "question", phase: "Step 2 of 5", paal: "Use path.join and path.resolve. Show why they're needed for cross-platform code.", answer_keywords: ["path.join", "path.resolve", "dirname", "__dirname"], seed_code: `import path from 'path'\nimport { fileURLToPath } from 'url'\n\nconst __dirname = path.dirname(fileURLToPath(import.meta.url))\n\n// path.join: relative join — never produces absolute unless given one\nconst configPath = path.join(__dirname, '..', 'config', 'app.json')\n\n// path.resolve: always produces absolute path — uses CWD as base\nconst logPath = path.resolve('logs', 'app.log')  // /project/logs/app.log\n\n// path.extname, path.basename, path.dirname:\nconst file = '/project/src/utils/helper.ts'\nconsole.log(path.basename(file))           // 'helper.ts'\nconsole.log(path.basename(file, '.ts'))    // 'helper'\nconsole.log(path.extname(file))            // '.ts'\nconsole.log(path.dirname(file))            // '/project/src/utils'\n\nexport { configPath, logPath }`, feedback_correct: "✅ path.join for relative, path.resolve for absolute. Always use these — never string concatenation.", feedback_partial: "path.join(__dirname, 'relative') — handles OS separators. path.resolve() for absolute paths.", feedback_wrong: "path.join(__dirname, '..', 'config', 'app.json') — never: __dirname + '/config/app.json'", expected: "path.join and path.resolve" },
  { id: "step3", type: "question", phase: "Step 3 of 5", paal: "Access process.env for config. Validate required env vars at startup.", answer_keywords: ["process.env", "env", "required", "validate"], seed_code: `// process.env — environment variables\nconst PORT     = parseInt(process.env.PORT ?? '3000', 10)\nconst NODE_ENV = process.env.NODE_ENV ?? 'development'\nconst DB_URL   = process.env.DATABASE_URL\n\n// Validate required vars at startup (fail fast):\nfunction requireEnv(...keys) {\n  const missing = keys.filter(k => !process.env[k])\n  if (missing.length) {\n    console.error(\`Missing required env vars: \${missing.join(', ')}\`)\n    process.exit(1)  // die before accepting any traffic\n  }\n  return Object.fromEntries(keys.map(k => [k, process.env[k]]))\n}\n\nconst env = requireEnv('DATABASE_URL', 'JWT_SECRET', 'PORT')\n\n// Use dotenv for local dev:\n// import 'dotenv/config'   // at the very top — loads .env into process.env\n\nexport { PORT, NODE_ENV, requireEnv }`, feedback_correct: "✅ Validate all required env vars at startup — crash immediately rather than later at runtime.", feedback_partial: "process.env.KEY ?? 'default' for optional. requireEnv() to validate required ones at boot.", feedback_wrong: "function requireEnv(...keys) { const missing = keys.filter(k => !process.env[k]); if (missing.length) process.exit(1) }", expected: "process.env validation" },
  { id: "step4", type: "question", phase: "Step 4 of 5", paal: "Parse process.argv to build a simple CLI tool.", answer_keywords: ["process.argv", "cli", "args", "argv"], seed_code: `// process.argv: [node, script, ...userArgs]\n// process.argv[0] = node binary path\n// process.argv[1] = script path\n// process.argv[2+] = user-provided arguments\n\nconst args = process.argv.slice(2)\n\n// Simple flag parser:\nfunction parseArgs(argv) {\n  const result = { flags: {}, positional: [] }\n  for (let i = 0; i < argv.length; i++) {\n    if (argv[i].startsWith('--')) {\n      const key = argv[i].slice(2)\n      const val = argv[i + 1] && !argv[i + 1].startsWith('--') ? argv[++i] : true\n      result.flags[key] = val\n    } else {\n      result.positional.push(argv[i])\n    }\n  }\n  return result\n}\n\n// node cli.js --output ./dist --verbose src/index.ts\nconst { flags, positional } = parseArgs(args)\nconsole.log(flags.output)   // './dist'\nconsole.log(flags.verbose)  // true\nconsole.log(positional[0])  // 'src/index.ts'\n\n// For real CLIs, use: commander, yargs, or meow\nexport { parseArgs }`, feedback_correct: "✅ process.argv.slice(2) gives user args. For production CLIs, use commander or yargs.", feedback_partial: "process.argv[2+] are user args. Parse --flag value pairs manually or with a library.", feedback_wrong: "const args = process.argv.slice(2)  — slice(2) skips node and script path.", expected: "process.argv parsing" },
  { id: "step5", type: "question", phase: "Step 5 of 5", paal: "Build a config loader that merges defaults, file config, and env vars in the right priority order.", answer_keywords: ["merge", "config", "env", "defaults", "priority"], seed_code: `import fs from 'fs/promises'\nimport path from 'path'\nimport { fileURLToPath } from 'url'\n\nconst __dirname = path.dirname(fileURLToPath(import.meta.url))\n\nasync function loadConfig() {\n  // Priority: env vars > config file > defaults\n  const defaults = {\n    port:     3000,\n    logLevel: 'info',\n    dbPool:   5,\n  }\n\n  let fileConfig = {}\n  try {\n    const raw = await fs.readFile(path.join(__dirname, 'config.json'), 'utf8')\n    fileConfig = JSON.parse(raw)\n  } catch {}\n  // no config.json = fine, just use defaults + env\n\n  const envConfig = {\n    ...(process.env.PORT      && { port:     parseInt(process.env.PORT, 10) }),\n    ...(process.env.LOG_LEVEL && { logLevel: process.env.LOG_LEVEL }),\n  }\n\n  return { ...defaults, ...fileConfig, ...envConfig }  // right wins\n}\n\nexport { loadConfig }`, feedback_correct: "✅ Merge order: defaults → file → env vars (right wins). Silently skip missing config file.", feedback_partial: "{ ...defaults, ...fileConfig, ...envConfig } — rightmost wins on conflict.", feedback_wrong: "{ ...defaults, ...fileConfig, ...envConfig } — env overrides file, file overrides defaults.", expected: "Config loader with priority merge" },
];
const sideItems = [{ label: "Problem", id: "intro" }, { label: "Objectives", id: "objectives" }, { label: "Step 1 — fs.promises", id: "step1" }, { label: "Step 2 — path", id: "step2" }, { label: "Step 3 — process.env", id: "step3" }, { label: "Step 4 — argv CLI", id: "step4" }, { label: "Step 5 — Config loader", id: "step5" }];
export default createINPACTEngine({ NODES, sideItems, problemNum: "NODE-F01", title: "fs, path & process", shortName: "NODE — FS & PATH" });
