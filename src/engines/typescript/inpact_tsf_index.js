// ─── INPACT TypeScript Fundamentals — Curriculum Index ────────────────────────
//
// Drop all 10 engine files into your /problems directory alongside the existing
// inpact_engine_shared.js. Register them in your router just like p07, p09, etc.
//
// ──────────────────────────────────────────────────────────────────────────────

export const TS_FUNDAMENTALS_CURRICULUM = [
  {
    id: "tsf01",
    file: "inpact_tsf01_engine",
    shortName: "TS — PRIMITIVES",
    title: "Primitive Types & Variable Annotations",
    topics: [
      "number / string / boolean",
      "null vs undefined",
      "any vs unknown",
      "never",
      "const vs let inference",
      "literal types",
    ],
    why: "The foundation. Every other problem builds on knowing exactly what type each variable holds.",
  },
  {
    id: "tsf02",
    file: "inpact_tsf02_engine",
    shortName: "TS — FUNCTIONS",
    title: "Typing Functions",
    topics: [
      "Parameter & return type annotations",
      "void vs undefined",
      "Optional params (?)",
      "Default params",
      "Rest params (...args: T[])",
      "Arrow function types",
      "Function overloads",
    ],
    why: "Every API, event handler, and util function needs typed params. Getting this right eliminates a whole class of 'wrong argument' bugs.",
  },
  {
    id: "tsf03",
    file: "inpact_tsf03_engine",
    shortName: "TS — INTERFACES",
    title: "Interfaces — Contracts for Objects",
    topics: [
      "Required vs optional fields",
      "readonly modifier",
      "Interface extends",
      "Method signatures",
      "Declaration merging",
      "interface vs type alias",
    ],
    why: "Every API response, React props object, and database model uses interfaces. Non-negotiable.",
  },
  {
    id: "tsf04",
    file: "inpact_tsf04_engine",
    shortName: "TS — UNIONS",
    title: "Union Types, Intersections & Type Guards",
    topics: [
      "Union types (|)",
      "Intersection types (&)",
      "typeof narrowing",
      "instanceof narrowing",
      "in operator narrowing",
      "Discriminated unions",
      "Exhaustiveness with never",
    ],
    why: "Redux actions, API states, event systems — all discriminated unions. Type guards are how you use them safely.",
  },
  {
    id: "tsf05",
    file: "inpact_tsf05_engine",
    shortName: "TS — GENERICS",
    title: "Generics — Types as Parameters",
    topics: [
      "Generic functions <T>",
      "Generic constraints (extends)",
      "keyof + indexed access T[K]",
      "Multiple type params <T, U>",
      "Generic interfaces",
      "Type inference from parameters",
    ],
    why: "useState, Promise, Array, fetch wrappers — generics are the entire standard library. Understand them or fight the compiler forever.",
  },
  {
    id: "tsf06",
    file: "inpact_tsf06_engine",
    shortName: "TS — UTILITY TYPES",
    title: "Utility Types — Built-in Transformers",
    topics: [
      "Partial<T> for PATCH DTOs",
      "Required<T>",
      "Readonly<T>",
      "Pick<T, K>",
      "Omit<T, K>",
      "Record<K, V>",
      "ReturnType + Awaited",
      "Composing utility types",
    ],
    why: "Eliminate hundreds of lines of duplicate type definitions. The difference between a messy codebase and a clean one.",
  },
  {
    id: "tsf07",
    file: "inpact_tsf07_engine",
    shortName: "TS — ENUMS & TUPLES",
    title: "Enums & Tuples — Structured Constants",
    topics: [
      "Numeric enums",
      "String enums",
      "const enum (zero runtime cost)",
      "Enum vs string literal union",
      "Tuple types",
      "Labeled tuples",
      "as const for tuple returns",
    ],
    why: "HTTP methods, status codes, state machines, coordinate pairs, hook return values — both structures are essential.",
  },
  {
    id: "tsf08",
    file: "inpact_tsf08_engine",
    shortName: "TS — ASSERTIONS",
    title: "Type Assertions, Non-null & satisfies",
    topics: [
      "as Type assertion",
      "Non-null assertion (!)",
      "as const",
      "satisfies operator (TS 4.9+)",
      "Double assertion smell",
      "Type guards vs assertions",
    ],
    why: "DOM queries, JSON parsing, test mocks — assertions appear everywhere. Using them wrong silently destroys safety.",
  },
  {
    id: "tsf09",
    file: "inpact_tsf09_engine",
    shortName: "TS — UNCERTAIN OUTPUT",
    title: "Typing Uncertain Output",
    topics: [
      "Generic fetch wrapper Promise<T>",
      "unknown vs any for return types",
      "Conditional return types",
      "Overloads for per-input return types",
      "Result<T, E> for typed error handling",
    ],
    why: "The hardest TypeScript question. Fetch wrappers, parsers, plugin systems — get this right and nothing is un-typeable.",
  },
  {
    id: "tsf10",
    file: "inpact_tsf10_engine",
    shortName: "TS — ADVANCED",
    title: "Advanced Patterns — Senior-Level Toolkit",
    topics: [
      "Mapped types",
      "Key remapping (as `prefix${K}`)",
      "Template literal types",
      "infer keyword",
      "Ambient declarations (.d.ts)",
      "Module augmentation",
      "Recursive utility types (DeepReadonly)",
    ],
    why: "Library code, large codebases, senior interviews. You don't need these daily — but when you do, nothing else works.",
  },
];

export default TS_FUNDAMENTALS_CURRICULUM;
