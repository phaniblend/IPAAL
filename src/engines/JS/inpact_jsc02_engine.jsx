import createINPACTEngine from "../inpact_engine_shared";
const NODES = [
  { id: "intro", type: "reveal", phase: "Problem", content: { tag: "JS — BLOCK C #2", title: "Template Literals & Tagged Templates", body: `Template literals are more than just string interpolation.\nTagged templates are a powerful DSL mechanism used by\nstyled-components, gql, html, sql — all use tagged templates.\n\nconst html = String.raw\`<div class=\"box\">\${content}</div>\`\n\nA tag is just a function that receives the literal parts\nand the interpolated values separately — giving you complete\ncontrol over how the string is assembled.`, usecase: "styled-components (css\`color: red\`), GraphQL (gql\`query { ... }\`), safe SQL (sql\`SELECT * WHERE id = \${id}\`), i18n (t\`Hello \${name}\`) — tagged templates power major libraries." } },
  { id: "objectives", type: "objectives", phase: "Objectives", items: ["Multi-line strings and expression interpolation", "Nested template literals", "String.raw for escape-free strings", "Write a tagged template function from scratch", "Build a SQL-safe tagged template (parameterized queries)", "Build an HTML-escaping tag to prevent XSS"] },
  { id: "step1", type: "question", phase: "Step 1 of 5", paal: "Show template literals: multi-line, nested expressions, and ternary inside interpolation.", answer_keywords: ["template", "backtick", "interpolation", "${", "multiline"], seed_code: "// Step 1: template literal fundamentals\n\nconst name = 'Alice'\nconst score = 92\n\n// Multi-line (no \\n needed):\nconst card = `\n  Name: ${name}\n  Score: ${score}\n  Grade: ${score >= 90 ? 'A' : score >= 80 ? 'B' : 'C'}\n`\n\n// Any expression works:\nconst result = `${[1,2,3].map(n => n * 2).join(', ')}`  // '2, 4, 6'\n\n// Nested template literals:\nconst items = ['apple', 'banana']\nconst list = `Items: ${items.map(item => `• ${item}`).join('\\n')}`\n\n// Function call in interpolation:\nconst formatCurrency = n => n.toLocaleString('en-US', { style: 'currency', currency: 'USD' })\nconst price = `Total: ${formatCurrency(1234.5)}`  // 'Total: $1,234.50'\n\nexport { card, result, list, price }", feedback_correct: "✅ Any expression fits inside ${}. Multi-line, nested templates, function calls — all legal.", feedback_partial: "Backticks for template literals. ${expression} for any JS expression. Multi-line is natural.", feedback_wrong: "`Hello ${name}` — backticks, dollar-sign, curly braces for interpolation.", expected: "Template literal basics" },
  { id: "step2", type: "question", phase: "Step 2 of 5", paal: "Use String.raw to write regex and Windows paths without double-escaping every backslash.", answer_keywords: ["String.raw", "raw", "backslash", "escape", "regex"], seed_code: "// Step 2: String.raw — no escape processing\n\n// Without String.raw — must double-escape:\nconst regexStr = 'Hello\\\\sWorld'   // 'Hello\\\\sWorld' — double backslash needed\n\n// With String.raw — backslashes are literal:\nconst rawRegex = String.raw`Hello\\sWorld`   // 'Hello\\sWorld' — single backslash\nconst regex = new RegExp(rawRegex)           // /Hello\\sWorld/\n\n// Windows paths:\nconst path = String.raw`C:\\Users\\Alice\\Documents`   // no escaping needed\n\n// String.raw is just a tag function:\n// It receives { raw: [...] } as first arg — the un-escaped raw strings\nString.raw`Line1\\nLine2`   // 'Line1\\\\nLine2' — \\n is NOT a newline\n\nexport { rawRegex, path }", feedback_correct: "✅ String.raw suppresses escape processing. Perfect for regex strings and file paths.", feedback_partial: "String.raw`...` — backslashes are literal, \\n is two chars not a newline.", feedback_wrong: "String.raw`C:\\\\Users` — no double-escaping needed, backslashes pass through.", expected: "String.raw" },
  { id: "step3", type: "question", phase: "Step 3 of 5", paal: "Write a tagged template function from scratch — receive strings[] and values[], reconstruct with transformation.", answer_keywords: ["tag", "function", "strings", "values", "tagged template"], seed_code: "// Step 3: writing a tag function\n\n// A tag receives: (strings, ...values)\n// strings = array of literal string parts\n// values = interpolated expressions\n\nfunction emphasize(strings, ...values) {\n  return strings.reduce((result, str, i) => {\n    const value = values[i - 1]\n    return result + (value !== undefined ? `**${value}**` : '') + str\n  })\n}\n\nconst name = 'Alice'\nconst score = 95\nemphasize`Player ${name} scored ${score} points!`\n// 'Player **Alice** scored **95** points!'\n\n// Strings array is always one longer than values:\n// emphasize`A ${1} B ${2} C`\n// strings = ['A ', ' B ', ' C']  (3 items)\n// values  = [1, 2]               (2 items)\n\nexport { emphasize }", feedback_correct: "✅ Tag function: (strings, ...values). strings.length = values.length + 1. Interleave to reconstruct.", feedback_partial: "tag(strings, ...values) — strings are the literal parts, values are the ${} expressions.", feedback_wrong: "function tag(strings, ...values) { return strings.reduce((r, s, i) => r + (values[i-1] ?? '') + s) }", expected: "Tag function from scratch" },
  { id: "step4", type: "question", phase: "Step 4 of 5", paal: "Build a SQL-safe tagged template that parameterizes values automatically — preventing SQL injection.", answer_keywords: ["sql", "parameterized", "safe", "tag", "injection", "$1"], seed_code: "// Step 4: SQL-safe tagged template\n\nfunction sql(strings, ...values) {\n  const params = []\n  const query = strings.reduce((q, str, i) => {\n    if (i === 0) return str\n    params.push(values[i - 1])   // collect as parameter\n    return q + `$${params.length}` + str   // replace with $1, $2, ...\n  })\n  return { query, params }\n}\n\nconst userId = 1\nconst role = 'admin'\n\nconst { query, params } = sql`\n  SELECT * FROM users\n  WHERE id = ${userId}\n  AND role = ${role}\n`\n// query:  'SELECT * FROM users WHERE id = $1 AND role = $2'\n// params: [1, 'admin']\n// → safe parameterized query, no injection possible ✅\n\nexport { sql }", feedback_correct: "✅ sql tag collects values as params, replaces with $1 $2... — safe parameterized queries without ORM overhead.", feedback_partial: "sql`` returns { query, params }. Values become positional parameters, never interpolated raw.", feedback_wrong: "function sql(strings, ...values) — collect values[], replace with $1, $2... in the query string.", expected: "SQL-safe tagged template" },
  { id: "step5", type: "question", phase: "Step 5 of 5", paal: "Build an html`` tag that escapes interpolated values — preventing XSS while allowing safe HTML in the template.", answer_keywords: ["html", "escape", "xss", "tag", "safeHtml", "&amp;"], seed_code: "// Step 5: HTML-escaping tag — XSS prevention\n\nfunction escapeHtml(str) {\n  return String(str)\n    .replace(/&/g, '&amp;')\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;')\n    .replace(/\"/g, '&quot;')\n    .replace(/'/g, '&#39;')\n}\n\n// SafeHtml wrapper — marks a string as already-safe:\nclass SafeHtml {\n  constructor(str) { this.value = str }\n  toString() { return this.value }\n}\n\nfunction html(strings, ...values) {\n  const result = strings.reduce((acc, str, i) => {\n    if (i === 0) return str\n    const val = values[i - 1]\n    // SafeHtml instances pass through; everything else is escaped:\n    const safe = val instanceof SafeHtml ? val.value : escapeHtml(val)\n    return acc + safe + str\n  })\n  return new SafeHtml(result)\n}\n\nconst userInput = '<script>alert(\"xss\")</script>'\nconst safe = html`<div class=\"user\">${userInput}</div>`\n// '<div class=\"user\">&lt;script&gt;alert(&quot;xss&quot;)&lt;/script&gt;</div>'\n\nexport { html, SafeHtml, escapeHtml }", feedback_correct: "✅ html`` escapes all interpolated values. SafeHtml wrapper lets trusted HTML pass through. This is how Lit/Preact work.", feedback_partial: "html tag escapes ${value} automatically. SafeHtml marks pre-escaped values to skip double-escaping.", feedback_wrong: "html`<div>${userInput}</div>` — tag escapes userInput before interpolation.", expected: "HTML-escaping tag for XSS prevention" },
];
const sideItems = [
  { label: "Problem", id: "intro" }, { label: "Objectives", id: "objectives" },
  { label: "Step 1 — Basics", id: "step1" }, { label: "Step 2 — String.raw", id: "step2" },
  { label: "Step 3 — Tag function", id: "step3" }, { label: "Step 4 — SQL tag", id: "step4" },
  { label: "Step 5 — HTML tag", id: "step5" },
];
export default createINPACTEngine({ NODES, sideItems, problemNum: "JS-C02", title: "Template Literals & Tagged Templates", shortName: "JS — TAGGED TEMPLATES" });
