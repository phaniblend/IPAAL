import createINPACTEngine from "../inpact_engine_shared";
const NODES = [
  { id: "intro", type: "reveal", phase: "Problem", content: { tag: "JS — BLOCK C #3", title: "Regular Expressions — Real-World Patterns", body: `RegExp is one of the most powerful and most feared tools in JS.\nSenior devs know it cold because text manipulation is everywhere:\nvalidation, parsing, search-and-replace, log analysis.\n\nKey areas:\n  Syntax      — literals, character classes, quantifiers, anchors\n  Groups      — capturing, non-capturing, named groups\n  Lookaround  — lookahead, lookbehind (zero-width assertions)\n  Flags       — g, i, m, s, u, d\n  Iteration   — exec loop, matchAll, string.match`, usecase: "Email validation, URL parsing, log parsing, search highlighting, CSV parsing, code analysis — regex is unavoidable for serious text processing." } },
  { id: "objectives", type: "objectives", phase: "Objectives", items: ["Write patterns with character classes, quantifiers, anchors", "Use named capture groups for readable extractions", "Use lookahead/lookbehind for zero-width assertions", "Iterate all matches with matchAll (ES2020)", "Understand the flags: g i m s u d", "Know ReDoS — catastrophic backtracking — and how to avoid it"] },
  { id: "step1", type: "question", phase: "Step 1 of 5", paal: "Write patterns using character classes, quantifiers, and anchors. Extract parts of a date string.", answer_keywords: ["regex", "character class", "quantifier", "anchor", "capture group"], seed_code: "// Step 1: regex fundamentals\n\n// Literal chars: /hello/ matches 'hello' exactly\n// Character class: [abc] matches a, b, or c\n// Negated class: [^abc] matches anything NOT a, b, or c\n// Shorthand: \\\\d digit, \\\\w word char, \\\\s whitespace, . any (except newline)\n\n// Quantifiers:\n// + = one or more, * = zero or more, ? = zero or one\n// {3} = exactly 3, {2,4} = 2 to 4, {2,} = 2 or more\n\n// Anchors:\n// ^ = start of string (or line with m flag)\n// $ = end of string\n// \\\\b = word boundary\n\n// Date extraction:\nconst dateStr = '2024-01-15T09:30:00Z'\nconst dateRegex = /(\\\\d{4})-(\\\\d{2})-(\\\\d{2})/\nconst [, year, month, day] = dateStr.match(dateRegex)\n// year='2024', month='01', day='15'\n\n// Email validation (simplified but solid):\nconst emailRegex = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\\\.[a-zA-Z]{2,}$/\nemailRegex.test('user@example.com')   // true\nemailRegex.test('not-an-email')       // false\n\nexport { year, month, day }", feedback_correct: "✅ Character classes, quantifiers, and anchors are the alphabet of regex. Named groups make extractions self-documenting.", feedback_partial: "\\\\d = digit, \\\\w = word, [abc] = class, + = one+, * = zero+, ^ = start, $ = end.", feedback_wrong: "/(\\\\d{4})-(\\\\d{2})-(\\\\d{2})/ — groups in parens, {n} for exact count.", expected: "Regex fundamentals" },
  { id: "step2", type: "question", phase: "Step 2 of 5", paal: "Use named capture groups for readable extractions from a URL.", answer_keywords: ["named group", "?<name>", "groups", "match", "URL"], seed_code: "// Step 2: named capture groups (ES2018)\n\n// Named: (?<name>pattern) — access via match.groups.name\nconst urlRegex = /^(?<protocol>https?):\\/\\/(?<host>[^/]+)(?<path>\\/[^?#]*)?(?:\\\\?(?<query>[^#]*))?(?:#(?<fragment>.*))?$/\n\nconst url = 'https://api.example.com/users/42?role=admin#profile'\nconst { groups } = url.match(urlRegex)\n\n// groups.protocol  → 'https'\n// groups.host      → 'api.example.com'\n// groups.path      → '/users/42'\n// groups.query     → 'role=admin'\n// groups.fragment  → 'profile'\n\n// Named groups in replace:\nconst date = '2024-01-15'\nconst reformatted = date.replace(\n  /(?<year>\\\\d{4})-(?<month>\\\\d{2})-(?<day>\\\\d{2})/,\n  '$<day>/$<month>/$<year>'   // reference by name\n)\n// '15/01/2024'\n\nexport { groups, reformatted }", feedback_correct: "✅ Named groups (?<name>) make regex self-documenting. Access via match.groups.name. Use $<name> in replace.", feedback_partial: "(?<name>pattern) defines named group. match.groups.name accesses it.", feedback_wrong: "/(?<year>\\\\d{4})-(?<month>\\\\d{2})/.exec(str).groups.year", expected: "Named capture groups" },
  { id: "step3", type: "question", phase: "Step 3 of 5", paal: "Use lookahead (?=) and lookbehind (?<=) for zero-width assertions — match only if followed/preceded by something.", answer_keywords: ["lookahead", "lookbehind", "?=", "?<=", "zero-width"], seed_code: "// Step 3: lookahead and lookbehind\n\n// Positive lookahead (?=...) — match X only if followed by Y:\n// Insert comma before sequences of 3 digits not at end (number formatting):\nconst formatted = '1234567'.replace(/\\\\B(?=(\\\\d{3})+(?!\\\\d))/g, ',')\n// '1,234,567'\n\n// Positive lookbehind (?<=...) — match X only if preceded by Y:\nconst prices = 'USD100 EUR200 GBP300'\nprices.match(/(?<=USD)\\\\d+/)      // ['100'] — only USD amount\nprices.match(/(?<=USD|EUR)\\\\d+/g)  // ['100', '200']\n\n// Negative lookahead (?!...) — match X only if NOT followed by Y:\n/\\\\d+(?!\\.\\\\d)/.exec('3.14')  // matches '3' only (not .14 after)\n// Useful: match integers but not decimals\n\n// Negative lookbehind (?<!...)\nconst text = 'foo bar foobar'\ntext.match(/(?<!foo)bar/g)   // ['bar'] — 'bar' not preceded by 'foo'\n                              // foobar's 'bar' is skipped\n\nexport { formatted }", feedback_correct: "✅ Lookahead/lookbehind are zero-width — they check context without consuming characters.", feedback_partial: "(?=X) = only if followed by X. (?<=X) = only if preceded by X. (?!X) = NOT followed. (?<!X) = NOT preceded.", feedback_wrong: "/(?<=USD)\\\\d+/ matches digits only when preceded by 'USD'. (?=...) checks ahead without consuming.", expected: "Lookahead and lookbehind" },
  { id: "step4", type: "question", phase: "Step 4 of 5", paal: "Use matchAll to iterate all matches with full group details. Explain g/i/m/s/u/d flags.", answer_keywords: ["matchAll", "flags", "global", "multiline", "sticky"], seed_code: "// Step 4: matchAll and flags\n\nconst text = `\nERROR 2024-01-15 Connection refused\nINFO  2024-01-16 Server started\nERROR 2024-01-17 Timeout\n`\n\n// matchAll requires global flag, returns iterator:\nconst logPattern = /^(ERROR|INFO)\\\\s+(\\\\d{4}-\\\\d{2}-\\\\d{2})\\\\s+(.+)$/gm\n\nconst logs = [...text.matchAll(logPattern)].map(match => ({\n  level:   match[1],\n  date:    match[2],\n  message: match[3],\n  index:   match.index\n}))\n// [{ level:'ERROR', date:'2024-01-15', message:'Connection refused' }, ...]\n\n// FLAGS:\n// g = global (find all, used with matchAll/replace-all)\n// i = case insensitive\n// m = multiline (^ and $ match line start/end, not just string)\n// s = dotAll (. matches newlines too)\n// u = unicode (enables full Unicode matching, required for emoji in classes)\n// d = indices (adds match.indices with start/end positions, ES2022)\n\nconst withIndices = 'hello'.match(/l+/d)\n// withIndices.indices[0] = [2, 4] — the match span\n\nexport { logs }", feedback_correct: "✅ matchAll + gm flags + map = clean log parsing. d flag gives match positions.", feedback_partial: "matchAll(regex) needs g flag. Returns iterator of match objects with .groups and .index.", feedback_wrong: "[...text.matchAll(/pattern/gm)] — spread to array, each item has full match details.", expected: "matchAll and regex flags" },
  { id: "step5", type: "question", phase: "Step 5 of 5", paal: "Show ReDoS — catastrophic backtracking — and how to rewrite vulnerable patterns safely.", answer_keywords: ["ReDoS", "backtracking", "catastrophic", "safe", "atomic"], seed_code: "// Step 5: ReDoS — catastrophic backtracking\n\n// VULNERABLE pattern: nested quantifiers on overlapping groups\n// /^(a+)+$/ against 'aaaaaaaaaaaaaab'\n// The engine tries every possible combination of 'a+' groups\n// → exponential time: O(2^n) — hangs the process!\n\nconst vulnerable = /^(a+)+$/   // ❌ catastrophic backtracking\n// vulnerable.test('aaaaaaaaaaaaaaab')  // hangs for ~20+ chars\n\n// WHY: 'aaaaab' can be matched as:\n// (aaaaa), (aaaa)(a), (aaa)(aa), (aaa)(a)(a), ...\n// On failure, engine backtracks through ALL combinations\n\n// SAFE rewrite — remove redundancy:\nconst safe = /^a+$/   // ✅ equivalent and O(n)\n\n// More ReDoS patterns to avoid:\n// /(x+x+)+y/  — overlapping quantifiers\n// /.*.*pattern/  — greedy .* repeated\n\n// Detection: use regex-based linters (safe-regex npm package)\n// In Node/Express, always validate regex from user input\n\n// PRACTICAL SAFE PATTERNS:\n// ✅ /^[a-z0-9._%+-]+@[a-z0-9.-]+\\\\.[a-z]{2,}$/i  — email\n// ✅ /^\\\\d{4}-\\\\d{2}-\\\\d{2}$/  — date\n// ✅ /^https?:\\/\\//i  — protocol check\n\nexport { safe }", feedback_correct: "✅ ReDoS comes from nested quantifiers on overlapping patterns. Remove redundancy — /^a+$/ not /^(a+)+$/.", feedback_partial: "Nested quantifiers like (a+)+ can cause exponential backtracking. Simplify to remove redundancy.", feedback_wrong: "/(a+)+$/ is catastrophic. /a+$/ is safe. Avoid nested quantifiers on overlapping character classes.", expected: "ReDoS catastrophic backtracking" },
];
const sideItems = [
  { label: "Problem", id: "intro" }, { label: "Objectives", id: "objectives" },
  { label: "Step 1 — Fundamentals", id: "step1" }, { label: "Step 2 — Named groups", id: "step2" },
  { label: "Step 3 — Lookaround", id: "step3" }, { label: "Step 4 — matchAll/flags", id: "step4" },
  { label: "Step 5 — ReDoS", id: "step5" },
];
export default createINPACTEngine({ NODES, sideItems, problemNum: "JS-C03", title: "Regular Expressions", shortName: "JS — REGEX" });
