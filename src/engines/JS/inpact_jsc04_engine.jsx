import createINPACTEngine from "../inpact_engine_shared";
const NODES = [
  { id: "intro", type: "reveal", phase: "Problem", content: { tag: "JS — BLOCK C #4", title: "Numbers, Math & BigInt", body: `JavaScript has one Number type — IEEE 754 double-precision float.\nThis means all numbers share space between integers and decimals,\ncausing the famous 0.1 + 0.2 !== 0.3 problem.\n\nSenior devs know:\n  • Why floating point fails and how to work around it\n  • Number.isNaN vs isNaN (done in B01, reinforced here)\n  • parseInt / parseFloat gotchas\n  • BigInt for integers larger than Number.MAX_SAFE_INTEGER\n  • Math methods every developer reaches for`, usecase: "Financial calculations, game scores, IDs larger than 2^53, currency formatting, rounding strategies — all require precise number handling." } },
  { id: "objectives", type: "objectives", phase: "Objectives", items: ["Understand floating point precision and workarounds", "Use Number.isFinite, isInteger, isSafeInteger correctly", "Know parseInt radix and parseFloat edge cases", "Use BigInt for large integer arithmetic", "Use Math.trunc/round/ceil/floor/sign/clamp patterns", "Format numbers with toFixed, toPrecision, toLocaleString"] },
  { id: "step1", type: "question", phase: "Step 1 of 5", paal: "Explain floating point precision and show Number.EPSILON-based comparison.", answer_keywords: ["0.1", "0.2", "epsilon", "floating point", "precision"], seed_code: "// Step 1: floating point precision\n\n0.1 + 0.2           // 0.30000000000000004\n0.1 + 0.2 === 0.3   // false ← the famous bug\n\n// WHY: binary can't represent 0.1 or 0.2 exactly (like 1/3 in decimal)\n\n// FIX 1: Number.EPSILON comparison\nfunction almostEqual(a, b, epsilon = Number.EPSILON) {\n  return Math.abs(a - b) < epsilon\n}\nalmostEqual(0.1 + 0.2, 0.3)   // true ✅\n\n// FIX 2: multiply to integer, operate, divide back (for money)\nfunction addMoney(a, b) {\n  // Work in cents (integers) to avoid float errors:\n  return (Math.round(a * 100) + Math.round(b * 100)) / 100\n}\naddMoney(0.1, 0.2)   // 0.3 ✅\n\n// FIX 3: Use Intl.NumberFormat or a library (decimal.js) for currency\n\n// Safe integer range:\nNumber.MAX_SAFE_INTEGER   // 9007199254740991 (2^53 - 1)\nNumber.MIN_SAFE_INTEGER   // -9007199254740991\nNumber.isSafeInteger(9007199254740991)   // true\nNumber.isSafeInteger(9007199254740992)   // false — precision lost!\n\nexport { almostEqual, addMoney }", feedback_correct: "✅ 0.1+0.2≠0.3 due to binary float. Number.EPSILON for comparison. Multiply to int for money math.", feedback_partial: "Use Number.EPSILON for float comparison. Multiply to cents/integers for financial math.", feedback_wrong: "Math.abs(a - b) < Number.EPSILON for float equality. Work in integers for currency.", expected: "Floating point precision" },
  { id: "step2", type: "question", phase: "Step 2 of 5", paal: "Show parseInt radix gotchas, parseFloat edge cases, and Number() conversion.", answer_keywords: ["parseInt", "parseFloat", "radix", "NaN", "Number"], seed_code: "// Step 2: parseInt and parseFloat gotchas\n\n// parseInt ALWAYS needs a radix argument:\nparseInt('10', 10)    // 10  — decimal\nparseInt('10', 2)     // 2   — binary: '10' in base 2 = 2\nparseInt('0x1f', 16)  // 31  — hex\nparseInt('10', 8)     // 8   — octal\n\n// Without radix — dangerous:\nparseInt('010')   // 8 in old engines (octal), 10 in modern — inconsistent!\nparseInt('0x10')  // 16 — hex prefix auto-detected (exception)\n\n// parseInt stops at first non-numeric char:\nparseInt('42px')    // 42   — stops at 'p'\nparseInt('px42')    // NaN  — starts with non-digit\nparseFloat('3.14em') // 3.14 — same\n\n// Number() converts the WHOLE string or fails:\nNumber('42px')  // NaN  — can't convert 'px'\nNumber('42')    // 42\nNumber('')      // 0   ← gotcha!\nNumber(null)    // 0   ← gotcha!\nNumber(true)    // 1\nNumber(false)   // 0\n\n// Best practice:\n// parseInt(str, 10) for integers from strings with units\n// Number(str) for pure numeric strings\n// parseFloat for decimals that might have trailing chars\n\nexport {}", feedback_correct: "✅ parseInt always needs radix 10. Number('') = 0. parseInt stops at non-digit; Number() requires whole string.", feedback_partial: "parseInt(str, 10) for safety. Number() for pure strings. parseFloat for decimals with trailing units.", feedback_wrong: "parseInt('42px', 10) = 42. Number('42px') = NaN. Number('') = 0 (gotcha).", expected: "parseInt and parseFloat gotchas" },
  { id: "step3", type: "question", phase: "Step 3 of 5", paal: "Use BigInt for large integers beyond Number.MAX_SAFE_INTEGER — showing arithmetic and the n suffix.", answer_keywords: ["BigInt", "n suffix", "large integer", "MAX_SAFE_INTEGER"], seed_code: "// Step 3: BigInt — integers beyond 2^53\n\n// Regular number loses precision beyond MAX_SAFE_INTEGER:\nconst big = 9007199254740992\nbig + 1   // 9007199254740992 — wrong! precision lost\n\n// BigInt handles any integer exactly:\nconst bigN = 9007199254740992n   // 'n' suffix creates BigInt\nbigN + 1n  // 9007199254740993n — exact!\n\n// Arithmetic — both operands must be BigInt:\n10n + 20n   // 30n\n10n * 3n    // 30n\n10n / 3n    // 3n — integer division, no decimals!\n10n % 3n    // 1n\n10n ** 3n   // 1000n\n\n// Cannot mix BigInt and Number:\n// 10n + 5    // ❌ TypeError: Cannot mix BigInt and other types\n10n + BigInt(5)   // ✅ explicit conversion\nNumber(10n)        // 10 — convert back to number (precision lost if too large)\n\n// Comparisons work across types (no coercion issue):\n10n === 10   // false — different types\n10n == 10    // true  — == coerces\n10n > 5      // true  — comparison works\n\n// Use cases: database IDs, crypto, financial integers, timestamps\nconst snowflakeId = 1234567890123456789n  // Twitter Snowflake ID\n\nexport { bigN, snowflakeId }", feedback_correct: "✅ BigInt with n suffix. Can't mix with Number. Integer division only. For IDs > 2^53 this is essential.", feedback_partial: "42n is BigInt. Only BigInt ops with BigInt. 10n / 3n = 3n (truncates). Number() converts back.", feedback_wrong: "const b = 9007199254740993n — n suffix for BigInt. BigInt + Number = TypeError.", expected: "BigInt for large integers" },
  { id: "step4", type: "question", phase: "Step 4 of 5", paal: "Show Math methods: trunc vs floor for negatives, clamp pattern, random range, hypot.", answer_keywords: ["Math.trunc", "Math.floor", "clamp", "Math.random", "Math.hypot"], seed_code: "// Step 4: Math methods\n\n// trunc vs floor — differ for NEGATIVES:\nMath.trunc(-4.7)   // -4 — towards zero\nMath.floor(-4.7)   // -5 — towards negative infinity\nMath.ceil(-4.2)    // -4 — towards positive infinity\nMath.round(-4.5)   // -4 — rounds towards positive infinity at .5\n\n// sign — returns 1, -1, or 0:\nMath.sign(-5)  // -1\nMath.sign(0)   // 0\nMath.sign(3)   // 1\n\n// Clamp — keep value within [min, max]:\nconst clamp = (value, min, max) => Math.min(Math.max(value, min), max)\nclamp(15, 0, 10)   // 10\nclamp(-5, 0, 10)   // 0\nclamp(7,  0, 10)   // 7\n\n// Random integer in range [min, max] inclusive:\nconst randomInt = (min, max) =>\n  Math.floor(Math.random() * (max - min + 1)) + min\nrandomInt(1, 6)   // simulates a die\n\n// Pythagorean distance:\nMath.hypot(3, 4)         // 5 — sqrt(9+16)\nMath.hypot(1, 1, 1)      // sqrt(3) — works for 3D too\n\n// Log:\nMath.log2(1024)   // 10\nMath.log10(1000)  // 3\n\nexport { clamp, randomInt }", feedback_correct: "✅ trunc toward zero, floor toward -∞. clamp = Math.min(Math.max(v,min),max). randomInt with floor+random.", feedback_partial: "Math.trunc(-4.7)=-4, Math.floor(-4.7)=-5. clamp(v,min,max) = Math.min(Math.max(v,min),max).", feedback_wrong: "Math.floor(Math.random()*(max-min+1))+min for random int. Math.trunc truncates toward zero.", expected: "Math methods and clamp" },
  { id: "step5", type: "question", phase: "Step 5 of 5", paal: "Format numbers with toFixed, toPrecision, and Intl.NumberFormat for locale-aware output.", answer_keywords: ["toFixed", "toPrecision", "Intl.NumberFormat", "locale", "currency"], seed_code: "// Step 5: number formatting\n\n// toFixed — fixed decimal places (returns STRING):\n(3.14159).toFixed(2)   // '3.14'\n(1.005).toFixed(2)     // '1.00' ← floating point gotcha! (1.005 is 1.00499...)\n(1000).toFixed(2)      // '1000.00'\n\n// toPrecision — total significant digits:\n(123.456).toPrecision(4)   // '123.5'\n(0.000123).toPrecision(2)  // '0.00012'\n\n// Intl.NumberFormat — locale-aware, production-ready:\nconst usd = new Intl.NumberFormat('en-US', {\n  style: 'currency',\n  currency: 'USD',\n})\nusd.format(1234567.89)   // '$1,234,567.89'\n\nconst eur = new Intl.NumberFormat('de-DE', {\n  style: 'currency',\n  currency: 'EUR',\n})\neur.format(1234567.89)   // '1.234.567,89 €'\n\n// Compact notation:\nconst compact = new Intl.NumberFormat('en-US', { notation: 'compact' })\ncompact.format(1234567)   // '1.2M'\ncompact.format(999)       // '999'\n\n// Reuse the formatter for performance:\nconst fmt = new Intl.NumberFormat('en-US')\nconst numbers = [1000, 2000, 3000].map(n => fmt.format(n))\n// ['1,000', '2,000', '3,000']\n\nexport { usd, compact }", feedback_correct: "✅ toFixed returns a string. Intl.NumberFormat is the production choice — locale-aware, reusable.", feedback_partial: "toFixed(n) for decimal string. Intl.NumberFormat for locale/currency formatting.", feedback_wrong: "new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD' }).format(amount)", expected: "Number formatting" },
];
const sideItems = [
  { label: "Problem", id: "intro" }, { label: "Objectives", id: "objectives" },
  { label: "Step 1 — Float precision", id: "step1" }, { label: "Step 2 — parseInt/parseFloat", id: "step2" },
  { label: "Step 3 — BigInt", id: "step3" }, { label: "Step 4 — Math methods", id: "step4" },
  { label: "Step 5 — Formatting", id: "step5" },
];
export default createINPACTEngine({ NODES, sideItems, problemNum: "JS-C04", title: "Numbers, Math & BigInt", shortName: "JS — NUMBERS" });
