import createINPACTEngine from "../inpact_engine_shared";
const NODES = [
  { id: "intro", type: "reveal", phase: "Problem", content: { tag: "JS — BLOCK C #5", title: "Dates, Intl & Serialization", body: `The Date object is notoriously painful.\nDates in JS are UTC internally, but display in local time.\nMonth is 0-indexed. Date parsing is inconsistent across browsers.\n\nFor production: use date-fns or Temporal (TC39 Stage 3).\nFor interviews and reading code: know the Date API cold.\n\nIntl is the modern toolkit for locale-aware formatting of\ndates, numbers, and relative times — built into the browser.\n\nJSON.stringify/parse with replacer/reviver lets you\ncustomize serialization and handle Date roundtrips safely.`, usecase: "Every app shows dates. Logs need timestamps. APIs serialize JSON. Knowing when Date fails and how Intl helps is everyday senior knowledge." } },
  { id: "objectives", type: "objectives", phase: "Objectives", items: ["Create and manipulate Date objects safely", "Know the month 0-indexing gotcha and timezone traps", "Use Intl.DateTimeFormat for locale-aware date display", "Use Intl.RelativeTimeFormat for '2 hours ago'", "Use JSON.stringify replacer to control serialization", "Use JSON.parse reviver to restore Date objects"] },
  { id: "step1", type: "question", phase: "Step 1 of 5", paal: "Create Date objects and show the month-0 gotcha, timezone trap, and safe UTC construction.", answer_keywords: ["Date", "getMonth", "UTC", "timezone", "new Date"], seed_code: "// Step 1: Date construction gotchas\n\n// Month is 0-indexed (January = 0, December = 11):\nconst jan = new Date(2024, 0, 15)  // January 15, 2024 ← NOT month 0!\nconst dec = new Date(2024, 11, 25) // December 25, 2024\n\njan.getMonth()     // 0 — not 1!\njan.getMonth() + 1 // 1 — always add 1 when displaying\n\n// String parsing — NEVER rely on non-ISO formats:\nnew Date('January 15, 2024')   // Implementation-defined (works in Chrome, may fail)\nnew Date('2024-01-15')         // ✅ ISO 8601 — reliable\nnew Date('2024-01-15T12:00:00Z') // ✅ explicit UTC\n\n// TIMEZONE TRAP:\nnew Date('2024-01-15')   // Treated as UTC midnight → may show Jan 14 in UTC-5!\nnew Date('2024-01-15T00:00:00')  // Treated as LOCAL time\nnew Date('2024-01-15T00:00:00Z') // Explicitly UTC\n\n// Safe timestamp handling:\nconst now = Date.now()   // milliseconds since epoch — use this for perf\nconst d = new Date(now)\n\n// Date arithmetic:\nconst tomorrow = new Date(now + 24 * 60 * 60 * 1000)\nconst nextWeek = new Date(d)\nnextWeek.setDate(d.getDate() + 7)  // mutates! ← careful\n\nexport { jan, dec }", feedback_correct: "✅ Month is 0-indexed. Parsing non-ISO strings is unreliable. Always use ISO 8601 or explicit UTC.", feedback_partial: "new Date(y, 0, 15) = January (0=Jan). String parsing: use ISO 8601 only.", feedback_wrong: "Month 0=Jan,11=Dec. new Date('2024-01-15T00:00:00Z') for explicit UTC. Date.now() for timestamp.", expected: "Date construction gotchas" },
  { id: "step2", type: "question", phase: "Step 2 of 5", paal: "Use Intl.DateTimeFormat for locale-aware dates and Intl.RelativeTimeFormat for 'X ago' strings.", answer_keywords: ["Intl.DateTimeFormat", "RelativeTimeFormat", "locale", "format", "ago"], seed_code: "// Step 2: Intl for date formatting\n\nconst date = new Date('2024-01-15T12:30:00Z')\n\n// Intl.DateTimeFormat — locale-aware:\nconst usFormat  = new Intl.DateTimeFormat('en-US', { dateStyle: 'full', timeStyle: 'short' })\nconst deFormat  = new Intl.DateTimeFormat('de-DE', { dateStyle: 'full', timeStyle: 'short' })\nconst jaFormat  = new Intl.DateTimeFormat('ja-JP', { dateStyle: 'full' })\n\nusFormat.format(date)  // 'Monday, January 15, 2024 at 12:30 PM'\ndeFormat.format(date)  // 'Montag, 15. Januar 2024 um 12:30'\njaFormat.format(date)  // '2024年1月15日月曜日'\n\n// Custom options:\nconst custom = new Intl.DateTimeFormat('en-US', {\n  year: 'numeric', month: 'short', day: 'numeric',\n  weekday: 'short', hour: '2-digit', minute: '2-digit',\n  timeZoneName: 'short',\n})\ncustom.format(date)  // 'Mon, Jan 15, 2024, 12:30 PM UTC'\n\n// Intl.RelativeTimeFormat — 'X ago' or 'in X days':\nconst rtf = new Intl.RelativeTimeFormat('en', { numeric: 'auto' })\nrtf.format(-2, 'hours')   // '2 hours ago'\nrtf.format(1, 'day')      // 'tomorrow'\nrtf.format(-7, 'days')    // 'last week' (numeric: auto)\n\n// Helper:\nfunction timeAgo(date) {\n  const rtf = new Intl.RelativeTimeFormat('en', { numeric: 'auto' })\n  const diff = date - Date.now()\n  const minutes = Math.round(diff / 60000)\n  if (Math.abs(minutes) < 60) return rtf.format(minutes, 'minutes')\n  const hours = Math.round(diff / 3600000)\n  if (Math.abs(hours) < 24) return rtf.format(hours, 'hours')\n  return rtf.format(Math.round(diff / 86400000), 'days')\n}\n\nexport { timeAgo }", feedback_correct: "✅ Intl.DateTimeFormat for locale-aware dates. RelativeTimeFormat for '2 hours ago'. Both built-in, no library needed.", feedback_partial: "new Intl.DateTimeFormat(locale, options).format(date). RelativeTimeFormat.format(value, unit).", feedback_wrong: "new Intl.RelativeTimeFormat('en', {numeric:'auto'}).format(-2, 'hours') = '2 hours ago'.", expected: "Intl.DateTimeFormat and RelativeTimeFormat" },
  { id: "step3", type: "question", phase: "Step 3 of 5", paal: "Use JSON.stringify replacer and JSON.parse reviver to control serialization — including Date roundtrips.", answer_keywords: ["replacer", "reviver", "JSON.stringify", "JSON.parse", "Date"], seed_code: "// Step 3: JSON replacer and reviver\n\nconst data = {\n  id: 1,\n  name: 'Alice',\n  password: 'secret123',   // should be excluded\n  createdAt: new Date('2024-01-15'),\n  score: undefined,         // omitted by JSON by default\n}\n\n// REPLACER — control what's included:\nconst json = JSON.stringify(data, (key, value) => {\n  if (key === 'password') return undefined   // exclude sensitive fields\n  if (value instanceof Date) return { __type: 'Date', iso: value.toISOString() }\n  return value\n})\n// '{\"id\":1,\"name\":\"Alice\",\"createdAt\":{\"__type\":\"Date\",\"iso\":\"2024-01-15T00:00:00.000Z\"}}'\n\n// REVIVER — restore types on parse:\nconst restored = JSON.parse(json, (key, value) => {\n  if (value?.__type === 'Date') return new Date(value.iso)\n  return value\n})\n// restored.createdAt is a real Date object! ✅\n\n// Array replacer — whitelist of keys to include:\nconst compact = JSON.stringify(data, ['id', 'name'])\n// '{\"id\":1,\"name\":\"Alice\"}' — only these keys\n\n// Space argument for pretty-print:\nJSON.stringify({ a: 1, b: [1, 2] }, null, 2)\n\nexport { restored }", feedback_correct: "✅ replacer excludes/transforms values. reviver restores types. This is how you serialize Dates, Maps, custom types.", feedback_partial: "JSON.stringify(val, replacer, space). JSON.parse(str, reviver). replacer=(key,val)=>newVal.", feedback_wrong: "JSON.stringify(data, (key,val) => key==='pwd' ? undefined : val) — return undefined to exclude.", expected: "JSON replacer and reviver" },
  { id: "step4", type: "question", phase: "Step 4 of 5", paal: "Show structuredClone for deep cloning — the modern replacement for JSON.parse(JSON.stringify(obj)).", answer_keywords: ["structuredClone", "deep clone", "Date", "Map", "Set"], seed_code: "// Step 4: structuredClone — the correct deep clone\n\nconst obj = {\n  name: 'Alice',\n  scores: [95, 87, 91],\n  createdAt: new Date(),\n  metadata: { role: 'admin' }\n}\n\n// OLD way — JSON roundtrip (broken for Date, Map, Set, undefined, functions):\nconst badClone = JSON.parse(JSON.stringify(obj))\n// badClone.createdAt is a STRING, not a Date! ❌\n\n// NEW way — structuredClone (ES2022, works in Node 17+, all modern browsers):\nconst goodClone = structuredClone(obj)\n// goodClone.createdAt is a real Date ✅\n// goodClone.scores is a new array ✅\n// Deep — nested objects are also new instances ✅\n\n// structuredClone handles: Date, Map, Set, ArrayBuffer, TypedArray, RegExp\n// Does NOT handle: functions, DOM nodes, class instances (loses methods)\n\n// For class instances with methods, use manual cloning:\nclass Point {\n  constructor(x, y) { this.x = x; this.y = y }\n  distanceTo(other) { return Math.hypot(this.x-other.x, this.y-other.y) }\n  clone() { return new Point(this.x, this.y) }   // manual clone\n}\n\n// Maps and Sets:\nconst map = new Map([['a', 1], ['b', 2]])\nconst clonedMap = structuredClone(map)  // ✅ real Map clone\n\nexport { goodClone }", feedback_correct: "✅ structuredClone is the correct deep clone. Handles Date/Map/Set. Doesn't preserve class methods.", feedback_partial: "structuredClone(obj) deep-clones with Date/Map/Set support. JSON roundtrip breaks Dates and omits undefined.", feedback_wrong: "structuredClone(obj) replaces JSON.parse(JSON.stringify(obj)) and handles Date, Map, Set correctly.", expected: "structuredClone deep clone" },
  { id: "step5", type: "question", phase: "Step 5 of 5", paal: "Show Intl.Collator for locale-aware string sorting and Intl.ListFormat for 'A, B, and C' formatting.", answer_keywords: ["Intl.Collator", "Intl.ListFormat", "sort", "locale", "collator"], seed_code: "// Step 5: Intl.Collator and ListFormat\n\n// Intl.Collator — locale-aware string comparison:\nconst names = ['Ångström', 'apple', 'Banana', 'cherry', 'åland']\n\n// Default JS sort — wrong for non-ASCII:\nnames.sort()  // ['Banana', 'apple', 'cherry', 'Ångström', 'åland']\n// Uppercase before lowercase, special chars misplaced ❌\n\n// Intl.Collator — correct locale-aware sort:\nconst collator = new Intl.Collator('en', { sensitivity: 'base' })\nnames.sort((a, b) => collator.compare(a, b))\n// ['åland', 'Ångström', 'apple', 'Banana', 'cherry'] — accent-aware ✅\n\n// sensitivity options:\n// 'base' — ignore case + accents (a=A=à)\n// 'accent' — ignore case, accents differ (a=A, à≠a)\n// 'case' — case differs, accents ignored (a≠A, à=a)\n// 'variant' — case + accents both matter (a≠A≠à)\n\n// Intl.ListFormat — 'A, B, and C':\nconst listFmt = new Intl.ListFormat('en', { type: 'conjunction' })\nlistFmt.format(['Alice', 'Bob', 'Carol'])   // 'Alice, Bob, and Carol'\nlistFmt.format(['Alice', 'Bob'])            // 'Alice and Bob'\nlistFmt.format(['Alice'])                   // 'Alice'\n\nconst orFmt = new Intl.ListFormat('en', { type: 'disjunction' })\norFmt.format(['red', 'green', 'blue'])   // 'red, green, or blue'\n\nexport { collator, listFmt }", feedback_correct: "✅ Intl.Collator for locale-aware sort. Intl.ListFormat for natural language lists. Both built-in.", feedback_partial: "new Intl.Collator(locale).compare(a,b) for sort. new Intl.ListFormat(locale,{type}).format(arr).", feedback_wrong: "names.sort((a,b) => new Intl.Collator('en').compare(a,b)) — locale-aware comparison.", expected: "Intl.Collator and ListFormat" },
];
const sideItems = [
  { label: "Problem", id: "intro" }, { label: "Objectives", id: "objectives" },
  { label: "Step 1 — Date gotchas", id: "step1" }, { label: "Step 2 — Intl dates", id: "step2" },
  { label: "Step 3 — replacer/reviver", id: "step3" }, { label: "Step 4 — structuredClone", id: "step4" },
  { label: "Step 5 — Collator/ListFormat", id: "step5" },
];
export default createINPACTEngine({ NODES, sideItems, problemNum: "JS-C05", title: "Dates, Intl & Serialization", shortName: "JS — DATES & INTL" });
